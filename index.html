<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>RxJava and Reactive Streams</title>

        <meta name="description" content="An exploration of reactive programming, focusing on RxJava and Reactive Streams">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/sky.css" id="theme">
        <link rel="stylesheet" href="css/coacoas.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Reactive Programming</h1>
                    <h3>RxJava and Reactive Streams</h3>
                    <caption><small><a href="http://coacoas.github.io/presentations-reactive">http://coacoas.github.io/presentations-reactive</a></small></caption>
                </section>

                <section>
                    <section>
                        <h2>What is Reactive?</h2>
                    </section>
                    <section>
                        <p>
                            Only a few years ago a large application had tens of servers, seconds of response time,
                            hours of offline maintenance and gigabytes of data. Today applications are deployed on
                            everything from mobile devices to cloud-based clusters running thousands of multi-core
                            processors. <strong>Users expect millisecond response times and 100% uptime.</strong> Data is measured in
                            Petabytes. Today's demands are simply not met by yesterdayâ€™s software architectures.
                        </p>
                    </section>
                    <section>
                        <h2>The Reacive Manifesto</h2>
                        <img height="400px" src="images/unabomber-sketch.jpg" alt="Manifesto?"/>
                    </section>
                    <section>
                        <img src="images/reactive-traits.svg" alt="Reactive Traits"/>
                    </section>
                    <section>
                        <table>
                            <tr>
                                <td>Responsive</td>
                                <td><strong>React</strong> to demand</td>
                            </tr>
                            <tr>
                                <td>Resilient</td>
                                <td><strong>React</strong> to failure</td>
                            </tr>
                            <tr>
                                <td>Elastic</td>
                                <td><strong>React</strong> to load</td>
                            </tr>
                            <tr>
                                <td>Message Driven</td>
                                <td><strong>React</strong> to events</td>
                            </tr>
                        </table>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Let's talk about data</h2>
                        <h3 class="fragment" data-fragment-index="1">And how we get it</h3>
                    </section>
                    <section>
                        <table>
                            <tr>
                                <th></th>
                                <th>Single Value</th>
                                <th>Multiple Values</th>
                            </tr>
                            <tr>
                                <td>Synchronous</td>
                                <td class="fragment" data-fragment-index="1">T</td>
                                <td class="fragment" data-fragment-index="2">Iterable[T]</td>
                            </tr>
                            <tr>
                                <td>Asynchronous</td>
                                <td class="fragment" data-fragment-index="3">Future[T]</td>
                                <td class="fragment" data-fragment-index="4">?</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h3>How do we get multiple values asynchronously?</h3>
                    </section>
                    <section>
                        <h3>How do we compose asynchronous values?</h3>
                    </section>
                    <section>
                        <h3>What is the essence of iteration?</h3>
                    </section>
                    <section>
                        <h3>Iteration</h3>
                        <pre><code lang="java">for (String item : items) {
   // do stuff
}</code></pre>
                        <ul>
                            <li class="fragment">Get the next element</li>
                            <li class="fragment">When is the iteration complete?</li>
                            <li class="fragment">How about when an error occurs?</li>
                        </ul>
                    </section>
                </section>

                <section>

                    <!-- section>
                        <h2>Observer[T]</h2>
                        <p>onNext(T item)</p>
                        <p>onError(Throwable exc)</p>
                        <p>onComplete()</p>
                    </section -->

                    <section>
                        <h1>Observable[T]</h1>
                        <p>Generates data to be observed</p>
                    </section>

                    <section>
                        <h3>Creating Observables</h3>
                        <ul>
                            <li class="no-bullet fragment">Observable.just(1)</li>
                            <li class="no-bullet fragment">Observable.just(1,2,3)</li>
                            <li class="no-bullet fragment">Observable.from(T[])</li>
                            <li class="no-bullet fragment">Observable.from(Iterable[T])</li>
                            <li class="no-bullet fragment">Observable.from(Future[T])</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Special Observables</h3>
                        <ul>
                            <li class="no-bullet">Observable.empty()</li>
                            <li class="no-bullet">Observable.never()</li>
                            <li class="no-bullet">Observable.error(Exception)</li>
                            <li class="no-bullet">Observable.interval(Long interval, TimeUnit unit)</li>
                            <li class="no-bullet">Observable.range(start, end)</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Custom Observables</h2>
                        <p>Remember those three properties of iteration?</p>
                        <ul>
                            <li class="fragment  ">Emit items</li>
                            <li class="fragment  ">Indicate errors</li>
                            <li class="fragment  ">Completion</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Custom Observables</h2>
                        <pre class="fragment  "><code lang="java">
Observable.create(subscriber -> {
    try {
        subscriber.onNext(1);
        subscriber.onNext(2);
        subscriber.onNext(3);
        subscriber.onComplete();
    } catch (Exception e) { 
        subscriber.onError(e);
    }
});
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Transforming Observables</h1>
                        <h4 class="fragment">Just like streams</h4>
                    </section>
                    <section>
                        <h2>Rx's Greatest Contribution</h2>
                        <div class="fragment">
                            <img src="images/marble-legend.png" alt="Marble Diagrams">
                            <h4>Marble Diagrams!</h4>
                        </div>
                    </section>
                    <section>
                        <h2>filter</h2>
                        <img class="marble"  src="images/filter.png" alt="">
                    </section>
                    <section>
                        <h2>Filer specializations</h2>
                        <ul>
                            <li>distinct, distinctUntilChanged</li>
                            <li>ignoreElements</li>
                            <li>first, last</li>
                            <li>skip, take</li>
                            <li>skipLast, takeLast</li>
                        </ul>
                    </section>
                    <section>
                        <h2>map</h2>
                        <div>
                            <div><caption>Create a new observable where each element is transformed according to the function</caption></div>
                            <div><img class="captioned" src="images/map.png" alt=""></div>
                        </div>
                    </section>
                    <section>
                        <h2>flatMap</h2>
                        <caption>Note that elements may be interleaved</caption>
                        <img class="captioned" src="images/flatMap.png" alt="">
                    </section>
                    <section>
                        <h2>concatMap</h2>
                        <caption>Use this to make sure order is preserved</caption>
                        <img class="captioned" src="images/concatMap.png" alt="">
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Combining Observables</h1>
                    </section>

                    <section>
                        <h2>Merge</h2>

                        <div>
                            <div><caption>Combine several observables of the same type to a single observable</caption></div>
                            <div><img class="captioned" src="images/merge.png" alt="Merge"/></div>
                        </div>
                    </section>

                    <section>
                        <h2>zip/zipWith</h2>

                        <div>
                            <div><caption>Emits items only when an element has been emitted on <em>all</em> observables</caption></div>
                            <div><img class="captioned" src="images/zip.png" alt="zip"/></div>
                        </div>
                    </section>

                    <section>
                        <h2>combineLatest</h2>

                        <div>
                            <div><caption>Emits when an element is emitted on <em>any</em> observable</caption></div>
                            <div><img class="captioned" src="images/combineLatest.png" alt="combineLatest"/></div>
                        </div>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Getting to the Data</h1>
                    </section>

                    <section>
                        <h3>subscribe()</h3>
                        <pre><code lang="java">

    Observable.just(1,2,3).
        map(i -> i + 1).
        subscribe(System.out::println);

    // 2
    // 3
    // 4
                        </code></pre>
                    </section>

                    <section>
                        <h2>Error Handling</h2>
                        <ul>
                            <li>Asynchronous execution means standard try/catch does not work</li>
                            <li>Requires asynchronous error reporting/handling</li>
                            <li>Exceptions are still cool</li>
                        </ul>
                    </section>

                    <section>
                        <h4>subscribe(onNext, onError)</h4>
                        <pre><code lang="java">
    Observable.just(2, 1, 0, -1).
        map(i -> 4 / i).
        subscribe(
          item -> System.out.println("Received: " + item),
          err  -> System.err.println("Error => " + err.getMessage()));

    // Received: 2
    // Received: 4
    // Error => / by zero
                        </code></pre>
                    </section>

                    <section>
                        <h3>Wait... there was that third thing</h3>
                        <h4>What about when a stream is completed? </h4>
                        <pre><code lang="java">
    Observable.just(3,2,1).
        map(i -> i * i).
        subscribe(
            item -> System.out.println("Received: " + item),
            err  -> System.err.println("Error => " + err.getMessage()),
            ()   -> System.err.println("Completed"));

    // Received: 9
    // Received: 4
    // Received: 1
    // Completed
                        </code></pre>

                    </section>

                    <section>
                        <h3>We found it!</h3>
                        <table>
                            <tr>
                                <th></th>
                                <th>Single Value</th>
                                <th>Multiple Values</th>
                            </tr>
                            <tr>
                                <td>Synchronous</td>
                                <td>T</td>
                                <td>Iterable[T]</td>
                            </tr>
                            <tr>
                                <td>Asynchronous</td>
                                <td>Future[T]</td>
                                <td class="em">Observable[T]</td>
                            </tr>
                        </table>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Threading</h1>
                    </section>

                    <section>
                        <h2>Threading</h2>
                        <ul>
                            <li>Most operations are, by default, single-threaded</li>
                            <li>Operations must be explicitly scheduled on other threads</li>
                            <li>Implemented with <em>Schedulers</em></li>
                        </ul>
                    </section>
                    
                    <section>
                        <h2>Schedulers</h2>
                        <ul>
                            <li>Schedulers.computation()</li>
                            <li>Schedulers.io()</li>
                            <li>Schedulers.from(Executor)</li>
                            <li>Schedulers.newThread()</li>
                            <li>... and more</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Assigning schedulers</h2>
                        <ul>
                            <li>subscribeOn</li>
                            <li>observeOn</li>
                        </ul>
                        <p>Makes threading much easier, but be careful!</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Hot / Cold</h1>
                    </section>
                    <section>
                        <h2>Cold Observables</h2>
                        <ul>
                            <li>Accept any number of subscribers</li>
                            <li>Emits the same values to all subscribers</li>
                        </ul>
                        <pre><code lang="java">
                            Observable&lt;Long> longs = Observable.just(1,2,3);
                            longs.subscribe(System.out::println);
                            // 1
                            // 2
                            // 3
                            longs.subscribe(System.out::println);
                            // 1
                            // 2
                            // 3
                        </code></pre>
                    </section>
                    <section>
                        <h2>Hot Observables</h2>
                        <ul>
                            <li>Emit values all the time</li>
                            <li>Each subscriber only gets the values emitted after subscription</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Hot Observables</h2>
                        <h3>Examples</h3>
                        <ul>
                            <li>Keyboard input</li>
                            <li>Mouse movement</li>
                            <li>Button clicks</li>
                            <li>Pub/Sub events</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Backpressure</h1>
                    </section>

                    <section>
                        <h2>Backpressure</h2>
                        <p>This is all asynchronous -- what happens if producers and consumers do not process
                        elements at the same rate?</p>
                    </section>

                    <section>
                        <h3>Slow Producer/Fast Consumer</h3>
                        <ul>
                            <li>Doesn't really matter.</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Fast Producer/Slow Consumer</h3>
                        <ul>
                            <li>Now we have a problem</li>
                            <li class="fragment">Observables are push-based</li>
                            <li class="fragment">Data "stacks up" while waiting for processing.</li>
                            <li class="fragment">Eventually fills up memory</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Backpressure Solutions</h2>
                        <h3>Reactive Pull</h3>
<pre><code>
    Observable.create(observer -> {
        observer.setProducer(requested -> {
            System.out.println("Requested " + requested + " more elements");
            for (int i = 0; i < requested && !subscriber.isUnsubscribed(); i++) {
                // Emit next items...
            }
        }
    });
</code></pre>
                        <caption>Ideal for cold observables</caption>
                    </section>

                    <section>
                        <h3>Throttling</h3>
                        <div class="cell">
                            <img src="images/sample.png" alt="Sample"/>
                            <caption>sample()</caption>
                        </div>
                        <div class="cell">
                            <img src="images/debounce.png" alt="Debounce"/>
                            <caption>debounce()</caption>
                        </div>
                        <div class="cell">
                            <img src="images/buffer.png" alt="Buffer"/>
                            <caption>buffer()</caption>
                        </div>
                        <div class="cell">
                            <img src="images/window.png" alt="Window"/>
                            <caption>window()</caption>
                        </div>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Reactive Streams</h1>
                        <caption><a href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a></caption>
                    </section>
                    <section>
                        <h2>Reactive Streams</h2>
                        <ul>
                            <li>When consumer operates faster than producer, push works great (such as standard Rx)</li>
                            <li>When producer operates faster than consumer, pull works best (don't overproduce)</li>
                        </ul>
                        <p>Now we get the best of both worlds</p>
                    </section>
                    <section>
                        <h2>Reactive Streams</h2>
                        <ul>
                            <li>Governs the interface between producers and consumers</li>
                            <li>Defines an API, a specification and a TCK</li>
                            <li>Version 1.0.0-RC5 released on April 10, 2015</li>
                        </ul>
                    </section>
                    <section>
                        <h2>RxJavaReactiveStreams</h2>
                        <ul>
                            <li>Implementation of Reactive Streams for RxJava</li>
                            <li>Allows for converting from Obervable to Publisher and vice versa</li>
                            <li>Also allows for converting rx.Subscriber to org.reactivestreams.Subscriber</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Other Implementations</h2>
                        <ul>
                            <li>Akka Streams</li>
                            <li>Ratpack</li>
                            <li>Reactive Rabbit</li>
                            <li>Reactor</li>
                            <li>Slick</li>
                            <li>Vert.x 3.0 (currently alpha)</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Specialized Libraries</h1>
                    </section>
                    <section>
                        <h1><a href="https://github.com/davidmoten/rxjava-jdbc">rxjava-jdbc</a></h1>
                        <ul class="no-bullet">
                            <li>Current version: 0.5.6</li>
                        </ul>
<pre><code lang="java">    Database db = new Database(connectionProvider);
    Observable&lt;Integer> score = db
        .select("select score from person where name &lt;> ? order by name")
        .parameter("XAVIER")
        .getAs(Integer.class)
        .last();
</code></pre>
                    </section>
                    <section>
                        <h1><a href="https://github.com/ReactiveX/RxNetty">RxNetty</a></h1>
                        <ul class="no-bullet">
                            <li>Non-blocking Network I/O</li>
                        </ul>
                    </section>
                    <section>
                        <h1><a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></h1>
                        <ul>
                            <li>Android-specific bindings</li>
                            <li>Most examples have it replacing AsyncTask</li>
                            <li>Also has bindings for lifecycle and lifecycle</li>
                            <li>Probably more. I don't actually write for Android... </li>
                        </ul>
<pre><code lang="java">    Observable.from("one", "two", "three", "four", "five")
        .subscribeOn(Schedulers.newThread())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(/* an Observer */);
</code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Common Problems</h1>
                    </section>
                    <section>
                        <h2>Testing</h2>
                        <ul>
                            <li>Testing async code is hard</li>
                            <li>RxJava provides Observable::toBlocking()</li>
                            <li>Works great for verifying data</li>
                        </ul>
<pre><code>
    List&lt;Integer&gt; ints = Observable.just(1,2,3).
        toList().toBlocking().single();
</code></pre>
                    </section>
                    <section>
                        <h2>TestSubscriber</h2>
                        <p>Allows assertions to be executed against subscribers in unit tests</p>
                    </section>
                    <section>
                        <h2>TestScheduler</h2>
                        <p>Allows testing events by manipulating time</p>
                    </section>
                    <section>
                        <h2>Debugging</h2>
                    </section>
                    <section>
                        <h2>Debugging</h2>
                        <ul>
                            <li>Debugging async code is hard</li>
                            <li>Imperative code has stack traces that make sense</li>
                            <li>Stack traces from onError will only show a slice of execution</li>
                            <li>Test individual steps</li>
                            <li>Keep steps pure!</li>
                        </ul>
                    </section>
                    <section>
                        <h2>RxJavaPlugins</h2>
                        <ul>
                            <li>Allow modification of default behavior</li>
                            <li>See <a href="https://github.com/ReactiveX/RxJava/wiki/Plugins">https://github.com/ReactiveX/RxJava/wiki/Plugins</a></li>
                        </ul>
                    </section>
                </section>

                <section>
                    <h1>Thank you</h1>
                    <div class="contact-info">
                        <div class="name">Bill Carlson</div>
                        <div class="twitter"><a href="http://www.twitter.com/@coacoas">@coacoas</a></div>
                    </div>
                </section>
            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
